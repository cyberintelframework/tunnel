#!/usr/bin/perl

#########################################
# Startup script for SURFnet IDS Sensor
# SURFnet IDS
# Version 1.04.03
# 24-11-2006
# Jan van Lith & Kees Trippelvitz
# Modified by Peter Arts
#########################################

################
# Changelog:
# 1.04.03 Added some more error handling
# 1.04.02 VLAN support
# 1.04.01 Rereleased as perl script
# 1.03.01 Released as part of the 1.03 package
# 1.02.12 Extended error message when using static IP configuration
# 1.02.11 Fixed a small bug in test of $networkconf and $checktapip
# 1.02.10 Fixed a bug with the generation of the sensor key
# 1.02.09 Added a check for the starthook.sh script
# 1.02.08 Added hook to the starthook.sh script
# 1.02.07 Initial release
################

use File::Basename;

$basedir = "/cdrom/scripts/";
do "$basedir/sensor.conf";
require "$basedir/network_if.conf";
require "$basedir/functions.inc.pl";

# Disabling dmesg output on the console
`dmesg -n 1`;

if ($netconf eq "vlan"){
 $statusif = "br1";
} else {
 $statusif = $br;
}

$chkstatus = chksensorstatus($statusif);
if ($chkstatus == 0) {
  print "${y}Sensor has already been started.${n}\n";
  $chk = chkidsmenu();
  if ($chk != 0) {
    system("$basedir/idsmenu");
  }
  exit;
}

# Checking disabled status of the sensor
$disabled = chkdisabled();
if ($disabled != 0) {
  print "${r}Sensor is disabled by admin${n}\n";
  $chk = chkidsmenu();
  if ($chk != 0) {
    system("$basedir/idsmenu");
  }
  exit;
}

# Checking the existance of ca.crt
$chkca = chkca();
if ($chkca != 0) {
  printmsg("Checking ca.crt:", $chkca);
  $chk = chkidsmenu();
  if ($chk != 0) {
    system("$basedir/idsmenu");
  }
  exit;
}

# Checking read/write status of the sensor
$chkrw = chkrw();
if ($chkrw != 0) {
  printmsg("Checking read/write status:", $chkrw);
  $chk = chkidsmenu();
  if ($chk != 0) {
    system("$basedir/idsmenu");
  }
  exit;
}

# Setting up interfaces
#@ifar = `cat /proc/net/dev | awk -F":" '{print \$1}' | awk '{print \$1}' | grep eth`;
#foreach(@ifar) {
#  $foundif = $_;
#  chomp($foundif);
#  `ifconfig $foundif up 2>/dev/null`;
#  printmsg("Interface $foundif up:", $?);
#}

# Giving the network interface some time to get ready.
# Fixes stuff with older or slow network cards
for ($i=$ifcounter; $i != 0; $i--) {
  system("/usr/bin/clear");
  print "Waiting for interfaces: $i\n";
  $if = getif();
  if ($if ne "false") {
    $i = 1;
  }
  sleep 1;
}
system("/usr/bin/clear");

$chkpump = chkpump();
if ($chkpump == 0) {
  `killall pump`
}

# Displaying the result of the checks done before the ifcounter
printmsg("Checking ca.crt:", $chkca);
printmsg("Checking read/write status:", $chkrw);

# Getting the network configuration method
printmsg("Network configuration method:", $netconf);

# Retrieving sensor name
$sensor = getsensor();
printmsg("Retrieving sensor name:", $sensor);

# Setting the serverurl
$serverurl = "$http://$server:$port";

# Checking if wget needs to authenticate the server certificate.
if ($checkcert == 0) {
  $wgetarg = "--no-check-certificate";
} else {
  $wgetarg = "";
}

#############################################
# STARTING NETWORK CONFIGURATION
#############################################
if ($netconf eq "dhcp" || $netconf eq "static") {
  # Getting the active interface
  $if = getif();
  printmsg("Checking active interface:", $if);
  if ($if eq "false") {
    $chk = chkidsmenu();
    if ($chk != 0) {
      system("$basedir/idsmenu");
    }
    exit;
  }

  if ($netconf eq "dhcp") {
    ##########################
    # NETCONF: DHCP
    ##########################
    # Start pump if needed
    $chkpump = chkpump($if);
    if ($chkpump != 0) {
      `pump -i $if 2>/dev/null`;
      printmsg("Starting DHCP client for $if:", $?);
    }
    
    # Setting the if detail string
    $ifdetail = "dhcp";
    
    $if_nm = getnetinfo("nm", $if);
    printmsg("Retrieving netmask:", $if_nm);

    $if_bc = getnetinfo("bc", $if);
    printmsg("Retrieving broadcast address:", $if_bc);

    $if_gw = getnetinfo("gw", $if);
    printmsg("Retrieving gateway address:", $if_gw);

  } elsif ($netconf eq "static") {
    ##########################
    # NETCONF: STATIC
    ##########################
    # Check if pump is running, if so, kill it.
    $chkpump = chkpump();
    if ( $chkpump == 0 ) {
      `killall pump`;
    }
  
    # Get the network information from the configuration file
    printmsg("Retrieving IP address:", $if_ip);
    printmsg("Retrieving netmask:", $if_nm);
    printmsg("Retrieving gateway:", $if_gw);
    printmsg("Retrieving broadcast address:", $if_bc);
    printmsg("Retrieving nameserver:", $if_ns);

    # Activate network configuration
    `ifconfig $if $if_ip netmask $if_nm broadcast $if_bc 2>/dev/null`;
    printmsg("Activating interface:", $?);
    
    # Checking gateway
    $chkgw = `ip route list |grep default | wc -l`;
    if ($chkgw != 0) {
       	for ($i=0 ; $i < $chkgw ; $i++) {
      		`ip route del default 2>/dev/null`;
    		printmsg("Delete default route:", $?);
	}
    }
    `ip route add default via $if_gw 2>/dev/null`;
    printmsg("Adding default route:", $?);
    
    open(RESOLV, ">/etc/resolv.conf");
    print RESOLV "nameserver $if_ns\n";
    close(RESOLV);

    # Setting the if detail string
    $ifdetail = "$if_nm|$if_gw|$if_bc";
  }

  # Checking if the interface has received an IP
  $if_ip = getifip($if);
  printmsg("IP address for $if:", $if_ip);
  if ($if_ip eq "false") {
    $chk = chkidsmenu();
    if ($chk != 0) {
      system("$basedir/idsmenu");
    }
    exit;
  }

  # Checking DNS resolver
  $servcheck = validip($server);
  if ($servcheck != 0) {
    $chkresolv = getresolv($server);
    if ($chkresolv ne "false") {
      $chkresolv = 0;
    }
    printmsg("Checking DNS resolver:", $chkresolv);
  } else {
    $chkresolv = 0;
    printmsg("Checking DNS resolver:", "ignore");
  }

  if ($chkresolv eq "false") {
    printmsg("Checking OpenVPN port:", "ignore");
    printmsg("Checking updates port:", "ignore");
  } else {
    # Checking if the ports to the server are unfiltered
    $openvpnport = getportstatus($if, 1194);
    printmsg("Checking OpenVPN port:", $openvpnport);
    if ($openvpnport ne "open") {
      $chk = chkidsmenu();
      if ($chk != 0) {
        system("$basedir/idsmenu");
      }
      exit;
    }
    $updateport = getportstatus($if, 4443);
    if ($updateport ne "open") {
      $chk = chkidsmenu();
      if ($chk != 0) {
        system("$basedir/idsmenu");
      }
      exit;
    }
    printmsg("Checking updates port:", $updateport);
  }

  if ($chkresolv ne "false") {
    # Checking wget auth
    printdelay("Checking wget authentication:");
    $chkwgetauth = chkwgetauth($wgetarg);
    printresult($chkwgetauth);
    if ($chkwgetauth != 0) {
      $chk = chkidsmenu();
      if ($chk != 0) {
        system("$basedir/idsmenu");
      }
      exit;
    }
  }
  
  # Checking if we need to get sensor certificates
  if ($sensor eq "false") {
    # No sensor certificate and key found yet, retrieve them.
    $vlanid="0";
    $sensor = getcerts($if_ip, $vlanid);
    if ($sensor ne "false") {
      $chksensor = 0;
    } else {
      $chksensor = "false";
    }
    printmsg("Retrieving certificates:", $chksensor);
  }

  if ($if ne "false" && $sensor ne "false") {
    # Updating the current configuration to the server
    printdelay("Updating status info to the server:");
    `wget -q $wgetarg -O $basedir/startclient.php "$serverurl/startclient.php?localip=$if_ip&ifmethod=$netconf&detail=$ifdetail&vlanid=0&keyname=$sensor"`;
    printresult($?);
  }

  if (-r "$basedir/startclient.php") {
    # Check for errors
    $err = 0;
    $errcheck = `grep "ERROR" $basedir/startclient.php | wc -l`;
    if ($errcheck != 0) {
      $errors = `grep "ERROR" $basedir/startclient.php`;
      chomp($errors);
      $errno = `grep "ERRNO" $basedir/startclient.php | awk '{print \$2}'`;
    }

    # Check for errors
    if ($errcheck != 0) {
      $errors = `grep "ERROR" $basedir/startclient.php`;
      chomp($errors);
      $errno = `grep "ERRNO" $basedir/startclient.php | awk '{print \$2}'`;
      if ($errno == 99) {
        print "${y}A tap IP address needs to be configured in the webinterface.\n";
        print "Start the sensor again when this is done.${n}\n";
        `$basedir/stopclient >/dev/null`;
        $chk = chkidsmenu();
        if ($chk != 0) {
          system("$basedir/idsmenu");
        }
        exit;
      } else {
        print "${r}An error occurred while updating status information.\n";
        print "$errors${n}\n";
      }
    }
  }

  $chkconf = chkclientconf();
  printmsg("Checking client.conf:", $chkconf);
  if ($chkconf != 0) {
    $fix = fixclientconf();
    printmsg("Fixing client.conf:", $fix);
  }

  # Creating tap device
  `openvpn --mktun --dev $tap`;
  printmsg("Creating tap device:", $?);

  $chkbridge = setbridge($br, $tap, $if, $netconf);
  printmsg("Setting up the bridge interface:", $chkbridge);

  if ($netconf eq "dhcp") {
    $chkpump = chkpump($br);
    if ($chkpump != 0) {
      sleeptimer("Waiting for bridging to finish:", 10);
      printdelay("Starting dhcp client for the bridge:");
      `pump -i $br`;
      printresult($?);
    }
  }

  # Starting OpenVPN
  printdelay("Starting OpenVPN:");
  `openvpn --config $basedir/client.conf --dev $tap --daemon`;
  printresult($?);

  # Setting up the ethernet loop prevention
  $ipt = setiptables($tap);
  printmsg("Ethernet loop prevention for $tap:", $ipt);

} elsif ($netconf eq "vlan") {
  ##########################
  # NETCONF: VLAN
  ##########################

  # Getting the active interface
  $if = getif();
  printmsg("Retrieving active interface:", $if);
  if ($if eq "false") {
    $chk = chkidsmenu();
    if ($chk != 0) {
      system("$basedir/idsmenu");
    }
    exit;
  }
  `ifconfig $if 0.0.0.0 up`;
  
  printmsg("Retrieving nameserver:", $if_ns);

  # Activate network configuration
  open(RESOLV, ">/etc/resolv.conf");
  print RESOLV "nameserver $if_ns\n";
  close(RESOLV);
  
  # Activating the 802.1q vlan kernel module
  `modprobe 8021q`;
  printmsg("Activating 802.1q kernel module:", $?);
  $i = 1;
  for my $key ( keys %vlan ) {
    $vlanid = $key;
    $br = "br$i";
    $tap = "tap$i";
    $vif = "$if.$vlanid";
    printmsg("Retrieving VLAN ID:", " $vlanid ");

    # Creating the vlan interface
    `vconfig add $if $vlanid`;
    if ($? != 0) {
      printmsg("Creating virtual interface:", $?);
      $chk = chkidsmenu();
      if ($chk != 0) {
        system("$basedir/idsmenu");
      }
      exit;
    } else {
      printmsg("Creating virtual interface:", "$if.$vlanid");
    }

    # Retrieving the network config method of the vlan
    $vlan_method = $vlan{$vlanid}{method};
    printmsg("Retrieving VLAN Method:", $vlan_method);
  
    # Check if pump is running, if so, kill it.
    $chkpump = chkpump($br);
    if ($chkpump == 0) {
      `killall pump`;
      printmsg("Killing all dhcp clients:", $?);
    }
  	
    # Creating tap device
    `openvpn --mktun --dev $tap`;
    printmsg("Creating tap device:", "$tap");
    
    # Check if the vlan routing tables are added the iproute2
    $checkrt_tables = `cat /etc/iproute2/rt_tables | grep "vlan$i" | wc -l`;
    if ($checkrt_tables == 0) {
      `echo "$i	vlan$i" >> /etc/iproute2/rt_tables`;
    }
  	
    # Setting up the bridge interface
    $chk = setbridge($br, $tap, $vif, $netconf);
    printmsg("Setting up the bridge:", $chk);
    `ifconfig $br up`;
    sleeptimer("Waiting for bridging to finish:", 10);
	
    if ($vlan_method eq "static") {
      $vlan_ip = $vlan{$vlanid}{if_ip};
      $vlan_nm = $vlan{$vlanid}{if_nm};
      $vlan_bc = $vlan{$vlanid}{if_bc};
      $vlan_gw = $vlan{$vlanid}{if_gw};
      printmsg("Retrieving IP_sensor:", $vlan_ip);
      printmsg("Retrieving netmask:", $vlan_nm);
      printmsg("Retrieving broadcast address:", $vlan_bc);
      printmsg("Retrieving gateway:", $vlan_gw);
      `ifconfig $br $vlan_ip netmask $vlan_nm broadcast $vlan_bc`;
      printmsg("Activating bridge interface:", $?);
  		
      # Setting up info for the server
      $ifmethodstring = "vlans";
      $netconfdetail = "$vlan_nm|$vlan_gw|$vlan_bc";
    } elsif ($vlan_method eq "dhcp"){
      printdelay("Starting dhcp client for the bridge:");
      `pump -i $br --no-gateway 2>/dev/null`;
      printresult($?);
      sleeptimer("Waiting for DHCP:", 10); 
      $vlan_gw = `pump -i $br -s | grep "Gateway:" | awk '{print \$2}'`;
      chomp($vlan_gw);
      $vlan_ip = `pump -i $br -s | grep "IP:" | awk '{print \$2}'`;
      chomp($vlan_ip);

      # Setting up info for the server
      $ifmethodstring = "vland";
      $netconfdetail = "dhcp";
    }

    # Setting up the routing rules for the vlan
    `ip route add default via $vlan_gw table vlan$i`;	
    printmsg("Adding vlan$i default route:", $?);
    `ip rule add from $vlan_ip table vlan$i`;
    `ip rule add to $vlan_ip table vlan$i`;

    # Adding default route for the vlan
    `ip route add default via $vlan_gw`;
    printmsg("Adding main default route:", $?);
    
    # Checking if we need to get sensor certificates
    if ($sensor eq "false") {
      # No sensor certificate and key found yet, retrieve them.
      $sensor = getcerts($vlan_ip, $vlanid);
      if ($sensor ne "false") {
        $chksensor = 0;
      } else {
        $chksensor = "false";
      }
      printmsg("Retrieving certificates:", $chksensor);
    }

    if ($sensor ne "false") {
      # Updating the current configuration to the server
      printdelay("Updating status info to the server:");
      `wget -q $wgetarg -O $basedir/startclient.php "$serverurl/startclient.php?localip=$vlan_ip&ifmethod=$ifmethodstring&detail=$netconfdetail&vlanid=$vlanid&keyname=$sensor"`;
      printresult($?);
    }

    if (-r "$basedir/startclient.php") {
      # Check for errors
      $err = 0;
      $errcheck = `grep "ERROR" $basedir/startclient.php | wc -l`;
      if ($errcheck != 0) {
        $errors = `grep "ERROR" $basedir/startclient.php`;
        chomp($errors);
        $errno = `grep "ERRNO" $basedir/startclient.php | awk '{print \$2}'`;
      }

      # Check for errors
      if ($errcheck != 0) {
        $errors = `grep "ERROR" $basedir/startclient.php`;
        chomp($errors);
        $errno = `grep "ERRNO" $basedir/startclient.php | awk '{print \$2}'`;
        chomp($errno);
        if ($errno == 99) {
          print "${y}A tap IP address needs to be configured in the webinterface.\n";
          print "Start the sensor again when this is done.${n}\n";
          `$basedir/stopclient >/dev/null`;
          $chk = chkidsmenu();
          if ($chk != 0) {
            system("$basedir/idsmenu");
          }
          exit;
        } else {
          print "${r}An error occurred while updating status information.\n";
          print "$errors${n}\n";
        }
      }
    }
    
    $chkclientconf = chkclientconf();
    printmsg("Checking client.conf:", $chkclientconf);
    if ($chkclientconf != 0) {
      $fix = fixclientconf();
      printmsg("Fixing client.conf:", $fix);
    }

    printdelay("Starting OpenVPN:");
    `openvpn --config $basedir/client.conf --dev $tap --daemon`;
    printresult($?);
		
    # Waiting for OpenVPN to finish
    sleeptimer("Waiting for OpenVPN:", 10);

    # Setting up the ethernet loop prevention
    $ipt = setiptables($tap);
    printmsg("Ethernet loop prevention $tap:", $ipt);
		
    # Deleting the default route to make sure routing goes correctly 
    # for the next vlan.
    `ip route del default via $vlan_gw`;
    
    $i++;	
  }
} else {
  printmsg("Unknown netconfiguration method:", "info");
  $chk = chkidsmenu();
  if ($chk != 0) {
    system("$basedir/idsmenu");
  }
  exit;
}

$sensor = getsensor();
printmsg("Retrieving sensor name again:", $sensor);
# Setting up the permissions of the .key and .crt file
`chmod 600 $basedir/$sensor.key`;
printmsg("Changing permissions sensor key:", $?);
`chmod 644 $basedir/$sensor.crt`;
printmsg("Changing permissions sensor cert:", $?);

# Sync the time with a timeserver
#$chktime = chktime();
#printmsg("Syncing time with ntpserver:", $chktime);

# Running user defined script in /cdrom/scripts/scripts.d/
if (-e "$basedir/scripts.d/user_startclient.pl") {
  system("$basedir/scripts.d/user_startclient.pl");
}

$chk = chkidsmenu();
if ($chk != 0) {
  system("$basedir/idsmenu");
}
