#!/usr/bin/perl

#########################################
# Stop script for SURFnet IDS Sensor
# SURFnet IDS
# Version 1.02.06
# 04-09-2006
# Jan van Lith & Kees Trippelvitz
# Modified by Peter Arts
#########################################

################
# Changelog:
# 1.02.06 Rereleased as perl script
# 1.02.05 Restructured the code
# 1.02.04 Added hook to the stophook.sh script
# 1.02.03 Initial release
################

# This script is run at reboot or shutdown.

################
# Variables    #
################
$basedir = "/cdrom/scripts";
do "$basedir/sensor.conf";
require "$basedir/functions.inc.pl";
require "$basedir/network_if.conf";

################
# Start script #
################

if ($netconf eq "vlan") {
  $statusif = "br1";
} else { 
  $statusif = "$br";
}

$chkstatus = chksensorstatus($statusif);
if ($chkstatus == 1) {
  print "${y}The sensor is not running. Nothing to stop.${n}\n";
  exit;
}

# Check the disk for read/write status.
$chkrw = chkrw();
printmsg("Checking read/write status:", $chkrw);

# Check for static of dynamic network connection
printmsg("Network configuration method:", $netconf);

# Removing iptables rules.
`iptables -F >/dev/null`;
printmsg("Clearing ethernet loop prevention:", $?);

# If OpenVPN is running, stop it
$chkopenvpn = chkopenvpn();
if ($chkopenvpn == 0) {
  # Stopping openvpn client.
  `killall openvpn`;
  printmsg("Stopping OpenVPN tunnel:", $?);
}

if ($netconf eq "dhcp" || $netconf eq "static") {
  # Get the active ethernet interface
  $if = getif();
  printmsg("Checking active interface:", $if);
  if ($netconf eq "dhcp") {
    # Get the bridge interface IP address.
    $if_ip = getifip($br);
    printmsg("Checking IP address:", $if_ip);
  } else {
    printmsg("Checking IP address:", $if_ip);
  }
  
  # If the bridge is present, remove it and restore the main interface
  
  if ($chkif == 0) {
    # Removing bridge and tap devices.
    `ifconfig $br down >/dev/null`;
    printmsg("Shutting down bridge interface:", $?);

    # Removing the active interface from the bridge
    `brctl delif $br $if >/dev/null`;
    printmsg("Removing $if from $br:", $?);

    # Checking if $tap device is present in the bridge
    $chkbrtap = `brctl show $br | grep $tap | wc -l`;
    chomp($chkbrtap);
    if ($chkbrtap != 0) {
      `brctl delif $br $tap >/dev/null`;
      printmsg("Removing $tap from $br:", $?);
    }

    # Removing the bridge
    `brctl delbr $br >/dev/null`;
    printmsg("Removing bridge interface:", $?);
  }
  
  $chktap = `ifconfig | grep $tap | wc -l`;
  if ($chktap != 0) {
    `openvpn --dev $tap --rmtun`;
    printmsg("Removing $tap device:", $?);
  }
  
  if ($netconf eq "dhcp") {
    # If pump is running for the bridge, kill it.
    $chkpump = `ps -ef | grep -i pump | grep -v grep | wc -l`;
    if ($chkpump != 0) {
      `killall pump >/dev/null`;
      printmsg("Killing all dhcp clients:", $?);
    }
    `pump -i $if >/dev/null`;
    printmsg("Starting pump for active interface:", $?);
  } elsif ($netconf eq "static") {
    printmsg("Configured IP address:", $if_ip);
    printmsg("Configured Netmask:", $if_nm);
    printmsg("Configured Gateway:", $if_gw);
    printmsg("Configured Broadcast:", $if_bc);
    printmsg("Configured Nameserver:", $if_ns);
    `ifconfig $if $if_ip netmask $if_nm broadcast $if_bc`;
    `route add -net default gw $if_gw`;
  }

  # Checking if wget needs to authenticate the server certificate.
  if ($checkcert == 0) {
    $wgetarg = "--no-check-certificate";
  } else {
    $wgetarg = "";
  }

  # Check if wget authentication is correct.
  $chkwgetauth = chkwgetauth($wgetarg);
  printmsg("Checking wget authentication:", $chkwgetauth);

  # Get the keyname.
  $sensor = getsensor();

  # Check if DNS name resolving works
  $chkresolv = getresolv($server);
  if ($chkresolv eq "false") {
    $chkresolv = 1;
  } else {
    $chkresolv = 0;
  }
  printmsg("Checking DNS resolver:", $chkresolv);

  # Generate the server URL
  $serverurl = "$http://$server:$port";

  # Get the localip.
  if ($netconf eq "dhcp") {
    $if_ip = getifip($if);
  }
  if ($chkresolv == 0) {
    `wget -q $wgetarg -O $basedir/stopclient.php "$serverurl/stopclient.php?localip=$if_ip&vlanid=0&keyname=$sensor"`;
    printmsg("Updating status information:", $?);
  }

  # Check for errors with the localip and tapip update.
  $checkerr = `cat $basedir/stopclient.php | grep "ERROR" | wc -l`;
  if ($checkerr > 0) {
    # Errors occured while updating localip and tapip.
    $errors = `cat $basedir/stopclient.php | grep "ERROR"`;
    print "${y}Error occured while updating status information.\n${n}";
    print "${r}$errors\n${n}";
  }
} elsif ($netconf eq "vlan") {
  $if = getif();
  printmsg("Retrieving active interface:", $if);
  $i = 1;
  for my $key ( keys %vlan ) {
    $vlanid = $key;
    $br = "br$i";
    $tap = "tap$i";
    printmsg("Retrieving VLAN ID:", " $vlanid ");
   	
    # Retrieving the network config method of the vlan
    $vlan_method = $vlan{$vlanid}{method};
    printmsg("Retrieving VLAN Method:", $vlan_method);
    
    if ($vlan_method eq "static") {
       $vlan_ip = $vlan{$vlanid}{if_ip};
       $vlan_gw = $vlan{$vlanid}{if_gw};
    }
    elsif ($vlan_method eq "dhcp") {
       $vlan_ip = getifip($br);
       $vlan_gw = `pump -i $br -s |grep "Gateway:" |awk '{print \$2}'`;
    }
    printmsg("Checking IP address for $br:", $vlan_ip);
    
   
  `ip route add default via $vlan_gw`;
  printmsg("Adding default gw for:", $br);
   
  # Checking if wget needs to authenticate the server certificate.
  if ($checkcert == 0) {
    $wgetarg = "--no-check-certificate";
  } else {
    $wgetarg = "";
  }

  # Check if wget authentication is correct.
  $chkwgetauth = chkwgetauth($wgetarg);
  printmsg("Checking wget authentication:", $chkwgetauth);

  # Get the keyname.
  $sensor = getsensor();

  # Check if DNS name resolving works
  $server = "honey.wind.surfnet.nl";
  $chkresolv = getresolv($server);
  if ($chkresolv eq "false") {
    $chkresolv = 1;
  } else {
    $chkresolv = 0;
  }
  printmsg("Checking DNS resolver:", $chkresolv);

  # Generate the server URL
  $serverurl = "$http://$server:$port";

  # Get the localip.
  if ($chkresolv == 0) {
    `wget -q $wgetarg -O $basedir/stopclient.php "$serverurl/stopclient.php?localip=$vlan_ip&vlanid=$vlanid&keyname=$sensor"`;
    printmsg("Updating status information:", $?);
  }

  # Check for errors with the localip and tapip update.
  $checkerr = `cat $basedir/stopclient.php | grep "ERROR" | wc -l`;
  if ($checkerr > 0) {
    # Errors occured while updating localip and tapip.
    $errors = `cat $basedir/stopclient.php | grep "ERROR"`;
    print "${y}Error occured while updating status information.\n${n}";
    print "${r}$errors\n${n}";
  }
    $chkpump = `ps -ef | grep -i "pump -i $br" | grep -v grep | wc -l`;
    if ($chkpump != 0) {
      `killall pump`;
       printmsg("Killing all dhcp clients:", $?);
    } 
  
    `ip route del default via $vlan_gw`;
    printmsg("Deleting default gw for:", $br);
    
    if ($chkif == 0) {
    printmsg("Removing bridge:", $br);
    `ifconfig $br down`;
    `brctl delif $br $if.$vlanid`;
    `brctl delif $br $tap`;
    `brctl delbr $br`;
    }
    $chktap = `ifconfig | grep $tap | wc -l`;
    if ($chktap != 0) {
      printmsg("Removing tap device:", $tap);
      `openvpn --dev $tap --rmtun`;
    }
    $chkif = chkif("$if.$vlanid");
    if ($chkif == 0) {
       printmsg("Removing vlan interface:", "$if.$vlanid");
      `vconfig rem $if.$vlanid`;
    }
       
    printmsg("Removing routing rules of:", "vlan $vlanid");
    `ip rule del from $vlan_ip >/dev/null`;
    `ip rule del to $vlan_ip >/dev/null`;
       
  $i++;
  }
}

# Add a hook to userdefined commands/actions that could be run.
if (-e "$basedir/scripts.d/user_stopclient.pl") {
  `$basedir/scripts.d/user_stopclient.pl`;
  printmsg("Starting user_stopclient.pl:", $?);
}
